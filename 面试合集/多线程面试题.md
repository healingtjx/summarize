#### 1.java中有几种方法可以实现一个线程？

继承Theard,实现Runable,使用Callable和FutureTask创建线程,使用线程池 Executor,使用spirng多线程(基于线程池),Timer(基于继承Theard)

#### **2.如何停止一个正在运行的线程？**

1.使用 volatile 类型变量

2.中断(适用于代码可能会阻塞的场景)，它并不是真正的中断一个正在运行的线程，而只是发出一个中断请求，然后由线程在下一个适合自己的时刻中断

自己（这个时刻被称之为取消点）

3.Futre 使用 cancel

4.重写interrupt 方法中断 不可中断阻塞 （例如 IO）

最好的方法是中断（interrupt）+条件变量（ps:使用stop太暴力）

#### **3.notify()和notifyAll()有什么区别？**

notify 唤醒一个，notifyAll 全部唤醒

所谓唤醒线程，另一种解释可以说是将线程由等待池移动到锁池，notifyAll调用后，会将全部线程由等待池移到锁池，然后参与锁的竞争，竞争成功则继续执行，如果不成功则留在锁池等待锁被释放后再次参与竞争。而notify只会唤醒一个线程

notify 会导致死锁

#### **4.****sleep()和 wait()有什么区别?**

1.sleep 方法来自类，wait 来自Object

2.sleep 无法释放锁，wait可以释放锁

3.wait只能在同步代码块内使用，sleep 可以在任何地方

4.sleep必须捕获异常，wait不需要

#### **5.****什么是Daemon线程？它有什么意义？**

是：守护线程，所有的用户线程都退出了，那么所有的守护线程就都会被杀死

意义:守护线程拥有自动结束自己生命周期的特性，而非守护线程不具备这个特点。

场景：JVM垃圾回收线程，守护线程经常被用来执行一些后台任务，但是呢，你又希望在程序退出时，或者说 JVM 退出时，线程能够自动关闭，此时，守护线程是你的首选

#### **6.java如何实现多线程之间的通讯和协作？**

1.wait/notify

2.Lock/Condition

当内置锁无法完成需求的时候，考虑用显式锁。(1.6之后性能内置锁性能有很大的提升)

线程1 用户 A  -> 用户B 

线程2 用户 B  -> 用户A

会导致 线程1 持有 A 等待 B，线程2 持有B 等待 A，从而死锁 

这种情况可以使用 定时或轮训tryLock

#### **7.什么是可重入锁（****ReentrantLock****）**

ReentrantLock和synchronized都是可重入锁

含义：可以重复递归调用的锁，在外层使用了锁之后，内层仍然可以使用，并且不发生死锁（前提是同一个对象或者class）

原理：每一个锁关联了一个请求计数器和一个占有线程，当计数器为0时，认为锁未别占用，线程请求一个未占有的锁，JVM会记录

锁的占有者，并且将请求计数器为1，如果再次请求获取这个锁，计数器加1，每次退出一个同步块就递减，直到请求计数器到0，才释放锁

#### **8.什么是不可重入锁**

#### **9.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法**

1.如果加了synchronized就不能，没加就可以

2.如果这个实例方法里面调用了wait,则其他加了synchronized可以进入

3.如果其他方法加了sysnchronized ,内部没有调wait，则不能

4.如果其他方法锁static 则可以调用（因为它的同步锁锁字节码）

#### **10.synchronized和java.util.concurrent.locks.Lock的异同？**

相同点：Lock可以完成synchronized实现的所有功能

不同点：synchronized 自动是否，Lock自动释放。

​               Lock可以实现非阻塞去获取锁（tryLock） 

#### **11.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？**

悲观锁:AQS

乐观锁:CAS

#### **12.SynchronizedMap和ConcurrentHashMap有什么区别？**

#### **13.CopyOnWriteArrayList可以用于什么应用场景？**

#### **14.什么叫线程安全？servlet是线程安全吗?**

当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么这个类就是线程安全的。

servlet不是线程安全的，因为servlet是单利模式。

#### **15.同步有几种实现方法？**

1.同步方法

2.同步块

3.volatile（线程可见性）

4.Look

5.ThreadLocal

#### **16.volatile有什么用？能否用一句话说明下volatile的应用场景？**

可以保证线程可见性

一般用于线程中断

上一个值不依赖于原有值的情况

#### **17.请说明下java的内存模型及其工作流程。**

#### **18.为什么代码会重排序？**

###### 缓存雪崩：

解决方法：在缓存的时候给过期时间加上一个随机值，这样就会大幅度的减少缓存在同一时间过期。

对于“Redis挂掉了，请求全部走数据库”这种情况，我们可以有以下的思路：

事发前：实现Redis的高可用(主从架构+Sentinel 或者Redis Cluster)，尽量避免Redis挂掉这种情况发生。

事发中：万一Redis真的挂了，我们可以设置本地缓存(ehcache)+限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)

事发后：redis持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

###### 缓存穿透

缓存穿透是指查询一个一不存在的数据。例如：从缓存redis没有命中，需要从mysql数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，造成缓存穿透。

###### 解决思路：

1:可以给key设置一些格式规则，然后查询之前先过滤掉不符合规则的Key。

2: 接口层增加校验，如用户鉴权校验，id 做基础校验，id<=0 的直接拦截

3:即便存储层查不到这个数据，也将返回的空对象设置到缓存里。下次再请求的时候，

直接从缓存取到空对象返回，这种情况一般会将空对象设置一个较短的过期时间，这样可以防止攻击者反复用同一个 id 暴力攻击

1.组合商品

id  name

2.组合商品详情表

id zid(组合商品id) goodsId(商品id) count (商品id)

下单流程:

第一步:

获取订单详情，获取订单 所有的 商品 和数量  商品list

第二步:获取 组合商品 数据 组合List

第三步比对

两层遍历

外层 组合List

内层 商品list

组合List

[

   {id:1,name:'测试组合',}

]