#### **一、jre、jdk、jvm的关系**

jdk是最小开发环境，由jre++java工具组成

jre是java运行最小环境，由jvm+核心内库类库组成

jvm是虚拟机，是java字节码运行的容器，如果只有jvm是无法运行java的，因为缺少了核心类库（jdk）

#### **二、JVM内存模型**

1.程序计数器（当前线程所执行的字节码的行号指示器）

2.Java虚拟机栈（线程执行方法的时候，虚拟机会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息）

3.本地方法栈（和虚拟机栈类似，主要用于存放native方法相关数据）

4.堆（唯一目的就是存放对象实例）

5.方法区（存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据 （java8移除了永久代（PermGen），替换为元空间（Metaspace）））

6.运行时常量池（用于存放编译后生成的各种字面量于符号引用，这部分内容将在方法加载后，放到方法区的运行时常量池中）

7.直接内存（jdk1.4加入的NIO类，引入的一种基于通道与缓冲区的I/O方式，它可以使用Native函数库直接分配到堆外内存，然后通过一个存储Java堆里面的DirectByteBuffer对象作为这块内存的引进进行操作）

#### **三、对象的4种引用**

1.强引用(程序代码之中普通存在的引用复制，即类似"Object obj = new Object()",无论任何情况下，强引用，垃圾回收器永远不会回收被引用对象。内存泄露的主要原因)

2.软引用（还有用，但非必要的对象，内存不足时候会被回收，适合缓存场景，JDK1.2后提高SoftReference类实现软引用）

3.弱引用(非必要的对象,不管内存是否充足，需要GC就会被回收，JDK1.2后提供WeakReference类实现弱引用)

4.虚引用(目的只是为了能在这个对象被GC的是时候收到一个系统通知，用于跟踪GC的状态、用于管理堆外内存，JDK1.2提供PhantomReference实现虚引用)

#### **四、对象的构成**

一个对象可以分成3个部分:对象头、实例数据、和对齐填充

对象头：主要包括两个部分

1.用于储存对象运行自身的运行数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。

2.元数据指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。

3.如果是数组，对象头还必须有一块用于记录数组长度的数据。

实例数据：存除对象真正有效信息(定义的各种类型的字段内容，还有继承的内容)，会根据虚拟机的分配策略(longs/doubles、ints、shorts/chars、bytes/booleans、oops)，会把相同宽度的字段分配到以前

对象填充:意义不大，主要在虚拟机规范中对象必须要是8哥字节的整数，所以当对象不满足这个条件时，就会利用占位符填充

#### **五、如何判断一个对象是否存活**

1.引用计数器

在对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加一，当引用失效时，计数器值就减一；当计数器为零就不可能在被引用(细节更加复杂)

2.可达性算法

思路就是通过一系列称之为“GC Roots”的根对象作为起始结点集，从这些结点开始，根据引用关系向下搜索，搜索过程所走过的路径称之为“引用链”，如果某个对象到GC Roots间没有任何引用链相连，就代表它对象不可达，说明这个对象不可能在被利用

#### **六、固定的GC Roots** 

1.方法区中类静态属性引用的对象（Java类的引用类型的静态变量）

2.在方法区常用引用的对象（字符串常量池里的引用）

3.本地方法栈中JNI引用的对象

4.Java虚拟机内部的引用(如基本数据类型对应的Class对象，一些异常对象，还有系统类加载器)

5.所有被同步锁持有的对象

6.反应Java虚拟机内部情况的JMXBean,JVMTI中注册的回调、本地代码缓存等。

#### **七、JVM类加载顺序**

1.加载(第一步通过一个类的全限定名来获取定义此类的二进制字节流。第二步将这个字节流所代表的静态存储结构转化为方法区运行时数据结构。第三步在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口)

2.验证(1.文件格式验证。2.元数据验证。3.字节码验证。4.符号引用验证。)

3.准备(正式类中定义的变量(即静态变量，被static修饰的变量)分配内存并设置类变量初始化的阶段)

4.解析(将常量池内的符号引用替换成直接引用)

5.初始化(为类的静态变量赋予正确的初始值（Java代码中被显式地赋予的值）)

#### **八、JVM三种类加载器**

1.启动类加载器(用于加载<JAVA_HOME>\lib目录下的文件,java核心类库，java.lang.*这种)

2.扩展类加载器(用于加载<JAVA_HOME>\lib\ext目录下的文件,扩展类库，JavaEE这种)

3.应用程序类加载器(用于加载classPath下面的类)

#### **九、双亲委派机制**

1.类加载器收到类加载请求

2.把请求委托给父加载器去完成，一直向上委托，直到启动类加载器。

3.启动类加载器，判断是否可以加载，可以直接加载(结束)；否则，抛出异常，通知子加载器加载

4.保障类的唯一性和安全性以及保障啦JDK核心类优先加载

#### **十、双亲委派模型有啥用**

保障java基础类在不同环境还是同一个Class对象，避免自定义类覆盖基础类问题，导致安全问题，也可以避免类的重复加载。

#### **十一、如何打破双亲委派**

1.自定义类加载器,继承ClassLoader类重写loadClass方法。

2.SPI： （Service Provider interface）

（1）：服务提供接口（服务发现机制）：

（2）：通过加载ClassPath下META_INF/services，自动加载文件里所定义的类

（3）：通过ServiceLoader.load/Service.providers方法通过反射拿到实现类的实例

SPI应用?

（1）：应用于JDBC获取数据库驱动连接过程就是应用这一机制

（2）：apache最早提供的common-logging只有接口.没有实现..发现日志的提供商通过SPI来具体找到日志提供商实现类

tomcat是如何打破双亲委派模型：

tomcat有着特殊性，它需要容纳多个应用，需要做到应用级别的隔离，而且需要减少重复性加载，所以划分为：/common 容器和应用共享的类信息，/server容器本身的类信息，/share应用通用的类信息,/WEB-INF/lib应用级别的类信息。整体可以分为：boostrapClassLoader->ExtensionClassLoader->ApplicationClassLoader->CommonClassLoader->CatalinaClassLoader（容器本身的加载器）/ShareClassLoader（共享的）->WebAppClassLoader。虽然第一眼是满足双亲委派模型的，但是不是的，因为双亲委派模型是要先提交给父类装载，而tomcat是优先判断是否是自己负责的文件位置，进行加载的。

#### **十二、双亲委派机制缺陷?**

1：双亲委派核心是越基础的类由越上层的加载器进行加载， 基础的类总是作为被调用代码调用的API，无法实现基础类调用用户的代码….

2.JNDI服务它的代码由启动类加载器去加载，但是他需要调独立厂商实现的应用程序，如何解决? 线程上下文件类加载器（Thread Context ClassLoader）， JNDI服务使用这个线程上下文类加载器去加载所需要的SPI代码，也就是父类加载器请求子类加载器去完成类加载动作Java中所有涉及SPI的加载动作基本上都采用这种方式，例如JNDI，JDBC

#### **十二、导致fullGC的原因**

1.老年代空间不足

2.永久代(方法区)空间不足

3.显示调用ststem.gc();

#### **十三、堆外内存的优缺点**

Ehcache中的一些版本，各种 NIO 框架，Dubbo，Memcache 等中会用到，NIO包下ByteBuffer来创建堆外内存 堆外内存，其实就是不受JVM控制的内存。

相比于堆内内存有几个优势：

减少了垃圾回收的工作，因为垃圾回收会暂停其他的工作。 加快了复制的速度。因为堆内在 flush 到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了复制这项工作。 可以扩展至更大的内存空间。比如超过 1TB 甚至比主存还大的空间。

缺点总结如下：

堆外内存难以控制，如果内存泄漏，那么很难排查，通过-XX：MaxDirectMemerySize来指定，当达到阈值的时候，调用system.gc来进行一次full gc 堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合 jstat查看内存回收概况，实时查看各个分区的分配回收情况， jmap查看内存栈，查看内存中对象占用大小， jstack查看线程栈，死锁，性能瓶颈

#### **十四、JVM经典的垃圾回收器**

1.Serial收集器(复制算法、单线程、新生代)

2.ParNew收集器(复制算法、多线程、新生代)

3.Parallel Scavenge收集器(复制算法、多线程、新生代、高吞吐量)

4.Serial Old收集器(标记-整理算法、单线程、老年代)

5.Parallel Old收集器(标记-整理算法、多线程、老年代,高吞吐量，JDK8默认采用 Parallel Scavenge + Parallel Old 的组合)

6.CMS收集器(标记-整理、老年代、垃圾回收线程几乎能做到与用户线程同时工作、吞吐量低、内存碎片)以牺牲吞吐量为代价来获得最短回收停顿时间-XX：+UseConcMarkSweepGC jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代） jdk1.9 默认垃圾收集器G1

场景:应用程序堆停顿时间很敏感、在JVM中有相对较多存活较长的对象(老年代比重大)，会更适合用GMS。

收集流程:1.找到GC Roots。2.并发标记(三色标记算法)三色标记算法处理并发标记出现对象变化情况：

黑：自己+子对象标记完成

灰：自己完成，子对象未完成

白：未标记

并发标记 黑 -》灰 -》白 重新标记 -》灰-》白引用失效，黑引用指向-》白，导致白泄露标 cms 处理方法是incremental update 方案( 增量更新)把黑色变成灰色 多线程下并发标记依旧会产生漏标问题，所以cms必须remark一遍(jdk1.9以后不用cms啦)

四个步骤

1）初始标记（CMS initial mark）

需要“Stop The World”，初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快

2）并发标记（CMS concurrent mark）

并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行

3）重新标记（CMS remark）

重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短

4）并发清除（CMS concurrent sweep）

清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的

缺陷:

1.降低总吞吐量（在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。）

2.无法处理“浮动垃圾”,会导致Full GC(在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。这一部分垃圾就称为“浮动垃圾”。)

3.大量空间碎片产生(标记-清除算法原因)

7.G1收集器

收集过程:

1.初始标记（Initial Marking）：仅仅只是标记一下GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实并没有额外的停顿。

2.·并发标记（Concurrent Marking）：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

3.·最终标记（Final Marking）：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

4.·筛选回收（Live Data Counting and Evacuation）：负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的。

处理方案:

1.SATB（snapshot at the begining）把白放入栈中，标记过程是和应用程序并发运行的（不需要Stop-The-World） 这种方式会造成某些是垃圾的对象也被当做是存活的，所以G1会使得占用的内存被实际需要的内存大。不过下一次就回收了 ZGC 处理方案： 颜色指针（color pointers） 2*42方=4T

2.：G1 收集器（新生代 + 老年代，在多 CPU 和大内存的场景下有很好的性能） G1在java9 便是默认的垃圾收集器，是cms 的替代者 逻辑分代，用分区（region）的思想（默认分2048份） 还是有stw 为解决CMS算法产生空间碎片HotSpot提供垃圾收集器，通过-XX：+UseG1GC来启用

G1中提供了三种模式垃圾回收模式

（1）：young gc（eden region被耗尽无法申请内存时，就会触发）

（2）：mixed gc（当老年代大小占整个堆大小百分比达到该阈值时，会触发）

（3）：full gc（对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发）

（4）：ZGC和shenandoah （oracle产收费） no stw