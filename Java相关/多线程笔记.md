#### **线程的安全性**

1.什么是线程安全

当多个线程访问某个类时，这个类始终能够表现出正确的行为，那么这个类就是线程安全的。

2.原子性

保证操作时一起完成

3.竞争条件

在并发编程中，由于不恰当的执行时序而出现的不正确的结果的情况。

常见的有 ：先检查后执行（Check - Then - Act）

4.内置锁

Java内置锁相当于互斥锁，这就意味着最多只有一个线程可以持有这个锁。

当线程A尝试获取获取一个线程B持有的锁时，线程A必须堵塞或者等待，知道线程B释放这个锁。

如果线程B永远不释放锁，那么线程A会一直等下去。

5.重入

 在已经获得锁的同步方法或同步代码块内部可以调用锁定对象的其他同步方法, 不需要重新获取锁

原理：

重入锁实现可重入性原理或机制是：每一个锁关联一个线程持有者和计数器，当计数器为 0 时表示该锁没有被任何线程持有，那么任何线程都可能获得该锁而调用相应的方法；当某一线程请求成功后，JVM会记下锁的持有线程，并且将计数器置为 1；此时其它线程请求该锁，则必须等待；而该持有锁的线程如果再次请求这个锁，就可以再次拿到这个锁，同时计数器会递增；当线程退出同步代码块时，计数器会递减，如果计数器为 0，则释放该锁。

6.锁保护

对于可能被多个线程同时访问的可变状态的变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量由这个锁保护。

7.活跃性和性能

当使用锁时，你应该清楚代码块中实现的功能，以及执行该代码是否需要很长时间。无论是执行计算密集的操作，还是执行某一个可能堵塞的操作，如果锁持有的时间过长，那么都会带来活跃性或性能问题。

（当长时间计算或者无法快速完成的操作（例如，网络IO或者控制台IO）一定不要持有锁）

#### **对象的共享**

1.可见性

2.重排序

在没有同步的情况下，编译器、处理器以及运行时等，都有可以对操作顺序进行一些意想不到的调整。

3.非原子的64位操作

4.加锁与可见性

加锁的含义不仅仅局限于互斥行为，还包括内存的可见性，为了确保所有线程都可以看到共享变量的最新值，所有执行读、写操作的线程必须在同一个锁上同步。

5.volatile变量

用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与内存操作一起重排序。

volatile操作不足以确保递增操作的原子性。

当且仅当满足下列所有条件时，才应该使用volatile变量

-当变量写入操作不依赖当前值，才应该使用volatile。

-当变量不会与其他状态一起纳入不变性条件。

-在访问时候不需要加速

6.发布和逸出

发布(publish)对象意味着其作用域之外的代码可以访问操作此对象。例如将对象的引用保存到其他代码可以访问的地方，或者在非私有的方法中返回对象的引用，或者将对象的引用传递给其他类的方法。

逸出的概念：一个对象在尚未准备好时就将它发布。

为了保证对象的线程安全性，很多时候我们要避免发布对象，但是有时候我们又需要使用同步来安全的发布某些对象。

逸出即为发布了本不该发布的对象。

不要在构造过程中使 this 引用逸出

7.线程封闭

如果仅在单线程内访问数据，就不需要同步。这种技术称之为线程封闭，这也是实现线程安全的最简单方法之一。

例如：swing，JDBC

8.Ad-hoc 线程封闭

是指维护线程封闭性的职责完全由程序实现来承担。

9.栈封闭

只能通过局部变量才能访问的对象

10.ThreadLocal类

这个类可以使线程中的某一个值与保存值关联起来。这个类提供啦get和set等接口访问方法，这些方法为每使用该变量的线程都存有一个独立副本，因此get返回时总是返回由当前执行线程set执行后的最新值。

11.不变性

如果某一个对象在创建过后其状态不能被修改，那么这种对象称之为不可变对象

不可变对象一定是线程安全的

满足一下条件，对象才是不可变的：

-对象创建后其状态不能修改。

-对象的所有域都是 final 类型（这样只能对每个域赋值一次，通过构造器初始化所有成员，进行深度拷贝，在get方法中不直接返回对象本身，而是克隆对象并返回克隆）。

-对象正确创建（在对象创建期间，this没有逸出）

12.Final 域

Final类型的域是不能被修改的（如果Final 域引用的对象是可变的，那么被引用的对象也是能被修改的）

13.使用Volatile类型来发布不可变对象

网上大佬理解

(1).cache对象在service()中只有一处写操作,但是多个线程都会执行这个写操作。比如A线程带入参数a1执行service方法之后，缓存里是number=a , lastFactors=[a];这时a2线程进入service方法带入a,执行BigInteger[] factors = cache.getFactors(i); 取得了缓存数据[a]进行判断时线程切换，来了个C线程带入参数c执行完了方法。实际上此时的缓存是c和[c].理论上线程B读的值已经是过期的了。。。只是因为“缓存”的业务意义使得这个过期值不会引起程序错误罢了。。。也就是说这个例子的线程安全体现在正好切合了这个业务。。。

(2).OneValueCache的不可变也是有限制的。BigInteger[]类型的数组接受外部参数后，用Arrays.copyOf能使得初始化后值不再变化。但是如果不是BigInteger类型而是其他类型，要保证该类型也是不可变对象才行。

14.安全发布的常用模式

要安全的发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见，一个正确的对象发布可以通过下面方式来实现

-在静态初始化函数中实例话对象

-将对象引用保存到volatile域或者AtomicReferance对象中

-将对象引用保存到某一个正确构造对象的final类型域中

-将对象引用到一个由锁保护的域中

15.事实不可变对象

在没有额外同步的情况下，任何线程低都可以安全地使用被安全发布的事是不可变对象。

16.对象发布需求取决于他的可变性

-不可变对象可以通过任意机制发布

-事是不可变对象必须通过安全方式来发布

-可变对象必须通过安全发送发布，并且必须是线程安全的或者某个锁保护起来的

17.安全的共享对象

当把对象发布时，需要考虑对象的访问方式，你需要知道在这个引用上可以执行那些操作。在使用它之前是否需要获得一个锁？是否需要修改它？或者只能读取它？

在并发程序中使用和共享对象时，可以使用一些实用的策略：

线程封闭： 对象被封闭在线程中，由一个线程拥有，并且只能在这个线程内修改。

只读共享：只能读的对象，可以被多个线程同时访问，不存在失效情况。

线程安全共享：线程安全的对象在其内部实现同步，因此多个线程通过对象的公有接口来访问它，不需要再来做同步。

保护对象：被保护的对象只能通过持有特定的锁来访问。包括封装在其他线程安全对象中的对象和由锁保护的对象。

#### **对象的组合**

1.设计线程安全的类

三大基本要素

-找出构成对象的所有变量

-找出约束状态变量的不变条件

-建立对象并发访问管理策略

2.依赖状态的操作

类的不变性条件与后验条件约束了在对象有哪些状态和状态转化是有效的。

例如：不能在空队列中移除一个元素，在删除元素前，必须保证队列是非空的。

3.状态所有权

所有权和封住性总是相互关联的：对象封装他拥有的状态，反正也成立，即它封住的状态拥有所有权。

4.实例封闭

将数据封装到对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总是持用正确的锁。

封闭机制更易于构造线程安全类，因为当封闭状态时，在分析类的线程安全时无需检查整个程序。

5.Java监视器模式

从线程封闭原则及其逻辑推论可以得出Java监视器模式。遵循监视器模式的对象的所有可变状态封装起来，并由对象自己的内置锁来保护。

6.车辆追踪

7.委托失效

如果某个类含有复合操作，这个类必须提供自己的加锁机制以确保复合操作都是原子操作，除非整个复合操作都可以委托给状态变量。

8.发布底层状态变量

如果一个状态说线程安全的，并且没有任何不变形条件约束它的值，在变量的操作上不存在任何不允许的状态转化，那么可以安全的发布这个变量。

9.客户端加锁与扩展类机制

客户端加锁机制与扩展类机制有许多共同点，二者都是将派生类的行为与基类的实现耦合在一起，正如扩展会破坏实现类的封装性，客户端加速同样会

破坏同步策略的封装性。

10.组合

示例：ImprovedList

11.将同步策略文档化

在文档中说明客户代码需要了解的线程安全性保证，以及代码维护人员需要了解的同步策略。

#### **基础构建模块**

1.同步容器类

实现方式：将它们的状态封装起来，并对每个共有方法进行同步，使得只有一个线程可以访问容器的状态。

2.并发容器

通过并发容器来代替同步容器，可以极大提高伸缩性并降低风险。

3.ConcurrentHashMap

弱化了size、isEmpty（实际上返回的是近似值），换取了get 、put、containsKey 和 remove 等方法等并发。

4.CopyOnWriteArrayList

"写入时复制"容器的线程安全性在于，只要正确地发布一个事是不可变的对象，那么在访问该对象时不需要进一步同步。在每次修改时，都会创建并

重新发布一个新的容器副本，从而实现可变形。

常用于迭代操作远远多于修改操作时。（例如ip白名单）

5.阻塞队列和生产者-消费者模式

在构建高可用应用程序时，有界队列是一种强大的资源管理工具；它们能抑制并防止过多的工作项，使应用程序在负载的情况下变得更加健壮。

7.串行线程封闭

连接池利用了串行线程封闭，将对象“借给”一个请求线程。只要对象池包含足够的内部同步来安全发布池中的对象，并且只要客户端代码不会发布池中

的对象，或者将对象放回给对象池就不在使用它，那么可以安全地在线程直接传递所有权。

8双端队列云工作密取

9.阻塞方法和中断方法

阻塞状态：BLOCKED,WAITING,TIMED_WAITING

10同步工具类

它们封装了一些状态，这些状态决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一种方法用于高效地等待

同步工具进入预期状态。

11.闭锁

闭锁时一种同步工具类，可以延迟线程的进度直到其达到终止状态。

 

12.FutureTask

FutureTask表示的计算机是通过Callable来实现的，相当于一种可生成结果的Runnable，并且可以处于以下三种状态：等待运行，正在运行，运行完成。

13.信号量

计数信号量用来控制同时访问某个特定资源的操作数量，或者同时执行某个置顶操作的数量。计数信号量还可以用来实现某种资源池，或者对容器施加边界。

14.栅栏

#### **任务执行**

1.在线程中执行任务

在理想情况下，各个任务都是相互独立的：任务并不依赖其他任务状态、结果或边界效应。独立性有助于实现并发，因此存在足够多的处理资源，那么这些独立

的任务都可以并行执行。

2.串行的执行任务

3.显式地任务创建线程

通过为每个请求创建一个新的线程来提供服务，从而实现更高的响应性

4.Executor

5.线程池

线程池从字面意思来看，是指管理一组同构工作线程的资源池。现代机器CPU基本都是多核系统，利用多线程可以明显提高系统的效率，但是如果不控制线程的使用，会给系统带来严重的后果，因此，JDK提供了线程池供我们使用。线程池是与工作队列（Work Queue）密切相关的，其中在工作队列中保存了所有等待执行的任务。工作者线程（Worker Thread）的任务很简单：从工作队列获取第一个任务，执行任务，然后返回线程池，并等待下一个任务。

线程池框架Executor

Executor : 所有线程池的接口。 

ExecutorService:增加Executor的行为（执行execute，关闭shutdown），是Executor实现类的最直接接口。

Executors : 提供一系列的工厂方法（静态方法），（直接调用）创建生成线程池。

eg：ExecutorService pool = Executors.newSingleThreadExecutor();

其中Executors生成的常见线程池可分为4类：

1、newSingleThreadExecutor

单个线程的线程池

2、newFixedThreadExecutor

固定数量线程池

3、newCacheThreadExecutor(推荐)

可缓存线程池，当线程池大小超过处理任务所需的线程，就会回收部分空闲线程。有任务来，又智能添加

4、newScheduleThreadExecutor

大小无限制线程池，支持定时和周期的执行线程